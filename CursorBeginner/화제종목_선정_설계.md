# 오늘의 화제 종목 선정 설계서

## 개요

미국 주식 시장에서 "오늘의 화제 종목"을 자동으로 선정하기 위한 데이터 소스 분석 및 구현 설계입니다.

---

## 1. 데이터 소스 장단점 비교

### 1.1 Yahoo Finance Screener (yahooquery)

#### 장점
- ✅ **공식 데이터**: Yahoo Finance 공식 API로 신뢰성 높음
- ✅ **실시간성**: 거래 시간 중 실시간 데이터 제공
- ✅ **다양한 지표**: 거래량, 상승률, 하락률 등 다양한 지표 제공
- ✅ **무료 사용**: 별도 API 키 불필요
- ✅ **안정성**: 대규모 트래픽 처리 가능한 인프라
- ✅ **구현 용이**: Python 라이브러리(yahooquery)로 간단한 구현

#### 단점
- ⚠️ **제한적 필터링**: 기본 스크리너만 제공, 복잡한 커스텀 필터링 어려움
- ⚠️ **데이터 포맷**: 일부 데이터는 추가 파싱 필요

---

### 1.2 ApeWisdom (apewisdom.io)

#### 장점
- ✅ **소셜 트렌드 반영**: Reddit WSB(WallStreetBets) 멘션 기반으로 실제 투자자 관심도 반영
- ✅ **24시간 집계**: 실시간 멘션 순위 제공
- ✅ **감성 분석**: 긍정/부정 감성 데이터 제공 가능

#### 단점
- ⚠️ **비공식 API**: 공식 API가 없어 웹 스크래핑 필요 (법적 리스크)
- ⚠️ **불안정성**: 웹사이트 구조 변경 시 스크래핑 로직 수정 필요
- ⚠️ **지연 가능성**: 스크래핑 처리 시간으로 인한 지연
- ⚠️ **ToS 위반 가능성**: 웹사이트 이용약관 위반 가능성

---

### 1.3 SwaggyStocks

#### 장점
- ✅ **감성 분석**: WSB 실시간 감성 분석 제공
- ✅ **트렌드 파악**: 소셜 미디어 기반 트렌드 반영

#### 단점
- ⚠️ **비공식 API**: 공식 API 부재, 웹 스크래핑 필요
- ⚠️ **불안정성**: 웹사이트 구조 변경에 취약
- ⚠️ **법적 리스크**: 스크래핑 시 이용약관 위반 가능
- ⚠️ **유지보수 부담**: 스크래핑 로직 지속적 관리 필요

---

## 2. 권장 데이터 소스 선정 및 근거

### 권장: **Yahoo Finance Screener (yahooquery)**

### 선정 근거

1. **서비스 컨셉과의 일치**
   - "거래량 기반 자동 선정"이라는 핵심 차별점과 완벽히 부합
   - `most_actives`를 통해 거래량 상위 종목을 객관적으로 선정 가능

2. **안정성과 신뢰성**
   - 공식 API로 장기적 안정성 보장
   - 법적 리스크 없음
   - 유지보수 부담 최소화

3. **구현 효율성**
   - Python 라이브러리로 간단한 구현
   - 빠른 개발 및 배포 가능

4. **데이터 품질**
   - 실시간 거래량 데이터는 시장의 실제 관심도를 가장 잘 반영
   - 거래량 급증은 종목의 화제성과 직접적인 상관관계

### 보완 전략

- **1차 선정**: Yahoo Finance `most_actives` 기반 거래량 상위 종목
- **2차 필터링**: `day_gainers`와 교집합하여 상승세를 보이는 종목 우선 선정
- **향후 확장**: 서비스 안정화 후 ApeWisdom 데이터를 참고용으로 추가 (선택적)

---

## 3. yahooquery Screener 사용 코드 예시

### 3.1 기본 설치 및 임포트

```python
# pip install yahooquery

from yahooquery import Screener
import pandas as pd
from datetime import datetime
```

### 3.2 거래량 상위 종목 조회

```python
def get_most_active_stocks(limit=10):
    """
    거래량 상위 종목 조회
    
    Args:
        limit: 반환할 종목 수 (기본값: 10)
    
    Returns:
        list: 종목 정보 딕셔너리 리스트
    """
    screener = Screener()
    
    try:
        # most_actives: 거래량 상위 종목
        data = screener.get_screeners('most_actives', count=limit)
        
        if not data or 'most_actives' not in data:
            return []
        
        quotes = data['most_actives']['quotes']
        
        # 필요한 정보만 추출
        stocks = []
        for quote in quotes:
            stock_info = {
                'symbol': quote.get('symbol', ''),
                'shortName': quote.get('shortName', ''),
                'regularMarketPrice': quote.get('regularMarketPrice', 0),
                'regularMarketChange': quote.get('regularMarketChange', 0),
                'regularMarketChangePercent': quote.get('regularMarketChangePercent', 0),
                'regularMarketVolume': quote.get('regularMarketVolume', 0),
                'marketState': quote.get('marketState', 'REGULAR')  # PRE, REGULAR, POST, CLOSED
            }
            stocks.append(stock_info)
        
        return stocks
    
    except Exception as e:
        print(f"Error fetching most active stocks: {e}")
        return []
```

### 3.3 상승률 상위 종목 조회

```python
def get_day_gainers(limit=10):
    """
    당일 상승률 상위 종목 조회
    
    Args:
        limit: 반환할 종목 수 (기본값: 10)
    
    Returns:
        list: 종목 정보 딕셔너리 리스트
    """
    screener = Screener()
    
    try:
        # day_gainers: 당일 상승률 상위
        data = screener.get_screeners('day_gainers', count=limit)
        
        if not data or 'day_gainers' not in data:
            return []
        
        quotes = data['day_gainers']['quotes']
        
        stocks = []
        for quote in quotes:
            stock_info = {
                'symbol': quote.get('symbol', ''),
                'shortName': quote.get('shortName', ''),
                'regularMarketPrice': quote.get('regularMarketPrice', 0),
                'regularMarketChange': quote.get('regularMarketChange', 0),
                'regularMarketChangePercent': quote.get('regularMarketChangePercent', 0),
                'regularMarketVolume': quote.get('regularMarketVolume', 0),
            }
            stocks.append(stock_info)
        
        return stocks
    
    except Exception as e:
        print(f"Error fetching day gainers: {e}")
        return []
```

### 3.4 통합 조회 함수

```python
def get_trending_stocks():
    """
    거래량과 상승률을 종합하여 화제 종목 조회
    
    Returns:
        dict: {
            'most_actives': [...],
            'day_gainers': [...],
            'timestamp': '2024-12-XX XX:XX:XX'
        }
    """
    screener = Screener()
    
    result = {
        'most_actives': [],
        'day_gainers': [],
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }
    
    try:
        # 거래량 상위 조회
        most_actives_data = screener.get_screeners('most_actives', count=20)
        if most_actives_data and 'most_actives' in most_actives_data:
            result['most_actives'] = most_actives_data['most_actives']['quotes']
        
        # 상승률 상위 조회
        day_gainers_data = screener.get_screeners('day_gainers', count=20)
        if day_gainers_data and 'day_gainers' in day_gainers_data:
            result['day_gainers'] = day_gainers_data['day_gainers']['quotes']
    
    except Exception as e:
        print(f"Error fetching trending stocks: {e}")
    
    return result
```

---

## 4. TOP 1 종목 선정 로직

### 4.1 선정 알고리즘

```python
def select_top_trending_stock():
    """
    TOP 1 화제 종목 선정
    
    선정 기준:
    1. 거래량 상위 종목 중에서
    2. 상승률이 양수인 종목 우선
    3. 거래량과 상승률을 가중 평균하여 점수 계산
    
    Returns:
        dict: 선정된 종목 정보 또는 None
    """
    screener = Screener()
    
    try:
        # 1. 거래량 상위 30개 조회
        most_actives_data = screener.get_screeners('most_actives', count=30)
        if not most_actives_data or 'most_actives' not in most_actives_data:
            return None
        
        most_actives = most_actives_data['most_actives']['quotes']
        
        # 2. 상승률 상위 종목 심볼 수집 (참고용)
        day_gainers_data = screener.get_screeners('day_gainers', count=10)
        gainer_symbols = set()
        if day_gainers_data and 'day_gainers' in day_gainers_data:
            gainer_symbols = {q.get('symbol') for q in day_gainers_data['day_gainers']['quotes']}
        
        # 3. 점수 계산 및 정렬
        scored_stocks = []
        
        for stock in most_actives:
            symbol = stock.get('symbol', '')
            volume = stock.get('regularMarketVolume', 0)
            change_percent = stock.get('regularMarketChangePercent', 0)
            price = stock.get('regularMarketPrice', 0)
            
            # 유효성 검사
            if not symbol or volume <= 0 or price <= 0:
                continue
            
            # 점수 계산 (거래량 70%, 상승률 30%)
            # 거래량 점수: 정규화 (0-100)
            volume_score = min(100, (volume / 100_000_000) * 100)  # 1억 기준 정규화
            
            # 상승률 점수: 양수면 보너스, 음수면 페널티
            if change_percent > 0:
                change_score = min(100, change_percent * 10)  # 10% 상승 = 100점
            else:
                change_score = max(-50, change_percent * 5)  # 하락 페널티
            
            # 가중 평균
            total_score = (volume_score * 0.7) + (change_score * 0.3)
            
            # 상승 종목 보너스
            if symbol in gainer_symbols:
                total_score += 20
            
            scored_stocks.append({
                'symbol': symbol,
                'shortName': stock.get('shortName', ''),
                'regularMarketPrice': price,
                'regularMarketChange': stock.get('regularMarketChange', 0),
                'regularMarketChangePercent': change_percent,
                'regularMarketVolume': volume,
                'score': total_score,
                'is_gainer': symbol in gainer_symbols
            })
        
        # 4. 점수 기준 정렬
        if not scored_stocks:
            return None
        
        scored_stocks.sort(key=lambda x: x['score'], reverse=True)
        top_stock = scored_stocks[0]
        
        # 5. 최소 기준 검증
        if top_stock['score'] < 10:  # 최소 점수 미달 시 None 반환
            return None
        
        return top_stock
    
    except Exception as e:
        print(f"Error selecting top trending stock: {e}")
        return None
```

### 4.2 상세 선정 로직 (대안)

```python
def select_top_stock_alternative():
    """
    대안 선정 로직: 거래량과 상승률 교집합 우선
    
    Returns:
        dict: 선정된 종목 정보 또는 None
    """
    screener = Screener()
    
    try:
        # 거래량 상위 20개
        most_actives_data = screener.get_screeners('most_actives', count=20)
        if not most_actives_data or 'most_actives' not in most_actives_data:
            return None
        
        most_actives = {q.get('symbol'): q for q in most_actives_data['most_actives']['quotes']}
        
        # 상승률 상위 20개
        day_gainers_data = screener.get_screeners('day_gainers', count=20)
        if not day_gainers_data or 'day_gainers' not in day_gainers_data:
            # 상승률 데이터 없으면 거래량 1위 반환
            first_stock = list(most_actives.values())[0]
            return {
                'symbol': first_stock.get('symbol'),
                'shortName': first_stock.get('shortName', ''),
                'regularMarketPrice': first_stock.get('regularMarketPrice', 0),
                'regularMarketChangePercent': first_stock.get('regularMarketChangePercent', 0),
                'regularMarketVolume': first_stock.get('regularMarketVolume', 0),
                'selection_reason': 'highest_volume'
            }
        
        day_gainers = {q.get('symbol'): q for q in day_gainers_data['day_gainers']['quotes']}
        
        # 교집합 찾기
        intersection = set(most_actives.keys()) & set(day_gainers.keys())
        
        if intersection:
            # 교집합이 있으면 거래량 기준으로 1위 선택
            intersection_stocks = [
                most_actives[symbol] for symbol in intersection
            ]
            intersection_stocks.sort(
                key=lambda x: x.get('regularMarketVolume', 0), 
                reverse=True
            )
            
            top_stock = intersection_stocks[0]
            return {
                'symbol': top_stock.get('symbol'),
                'shortName': top_stock.get('shortName', ''),
                'regularMarketPrice': top_stock.get('regularMarketPrice', 0),
                'regularMarketChangePercent': top_stock.get('regularMarketChangePercent', 0),
                'regularMarketVolume': top_stock.get('regularMarketVolume', 0),
                'selection_reason': 'volume_and_gain_intersection'
            }
        else:
            # 교집합이 없으면 거래량 1위 반환
            first_stock = list(most_actives.values())[0]
            return {
                'symbol': first_stock.get('symbol'),
                'shortName': first_stock.get('shortName', ''),
                'regularMarketPrice': first_stock.get('regularMarketPrice', 0),
                'regularMarketChangePercent': first_stock.get('regularMarketChangePercent', 0),
                'regularMarketVolume': first_stock.get('regularMarketVolume', 0),
                'selection_reason': 'highest_volume_fallback'
            }
    
    except Exception as e:
        print(f"Error selecting top stock: {e}")
        return None
```

---

## 5. 엣지 케이스 처리

### 5.1 통합 에러 처리 함수

```python
def get_top_stock_with_error_handling():
    """
    엣지 케이스를 모두 고려한 안전한 TOP 1 종목 선정
    
    Returns:
        dict: {
            'success': bool,
            'stock': dict or None,
            'error': str or None,
            'fallback_used': bool
        }
    """
    screener = Screener()
    result = {
        'success': False,
        'stock': None,
        'error': None,
        'fallback_used': False
    }
    
    try:
        # 케이스 1: 거래량 상위 데이터 조회
        most_actives_data = screener.get_screeners('most_actives', count=30)
        
        # 케이스 2: 데이터 없음 처리
        if not most_actives_data:
            result['error'] = 'No data from Yahoo Finance'
            return result
        
        if 'most_actives' not in most_actives_data:
            result['error'] = 'most_actives key not found'
            return result
        
        quotes = most_actives_data['most_actives'].get('quotes', [])
        
        # 케이스 3: 빈 리스트 처리
        if not quotes or len(quotes) == 0:
            result['error'] = 'Empty quotes list'
            return result
        
        # 케이스 4: 유효한 종목 필터링
        valid_stocks = []
        for quote in quotes:
            symbol = quote.get('symbol', '').strip()
            volume = quote.get('regularMarketVolume', 0)
            price = quote.get('regularMarketPrice', 0)
            
            # 필수 필드 검증
            if not symbol or symbol == '':
                continue
            
            # 거래량과 가격 유효성 검증
            if volume <= 0 or price <= 0:
                continue
            
            # 중복 제거 (심볼 기준)
            if any(s['symbol'] == symbol for s in valid_stocks):
                continue
            
            valid_stocks.append(quote)
        
        # 케이스 5: 유효한 종목이 없는 경우
        if not valid_stocks:
            result['error'] = 'No valid stocks found after filtering'
            return result
        
        # 케이스 6: 거래량 기준 정렬 및 TOP 1 선택
        valid_stocks.sort(
            key=lambda x: x.get('regularMarketVolume', 0), 
            reverse=True
        )
        
        top_stock = valid_stocks[0]
        
        # 최종 검증
        if not top_stock.get('symbol'):
            result['error'] = 'Top stock has no symbol'
            return result
        
        result['success'] = True
        result['stock'] = {
            'symbol': top_stock.get('symbol'),
            'shortName': top_stock.get('shortName', 'Unknown'),
            'regularMarketPrice': top_stock.get('regularMarketPrice', 0),
            'regularMarketChange': top_stock.get('regularMarketChange', 0),
            'regularMarketChangePercent': top_stock.get('regularMarketChangePercent', 0),
            'regularMarketVolume': top_stock.get('regularMarketVolume', 0),
            'marketState': top_stock.get('marketState', 'UNKNOWN')
        }
        
        return result
    
    except KeyError as e:
        result['error'] = f'KeyError: {str(e)}'
        return result
    except AttributeError as e:
        result['error'] = f'AttributeError: {str(e)}'
        return result
    except Exception as e:
        result['error'] = f'Unexpected error: {str(e)}'
        return result
```

### 5.2 시장 상태별 처리

```python
def get_top_stock_by_market_state():
    """
    시장 상태(장 전/장 중/장 후/휴장)에 따른 처리
    
    Returns:
        dict: 선정된 종목 정보 또는 None
    """
    screener = Screener()
    
    try:
        data = screener.get_screeners('most_actives', count=10)
        
        if not data or 'most_actives' not in data:
            return None
        
        quotes = data['most_actives']['quotes']
        
        if not quotes:
            return None
        
        # 첫 번째 종목의 시장 상태 확인
        market_state = quotes[0].get('marketState', 'UNKNOWN')
        
        # 시장 상태별 처리
        if market_state == 'CLOSED':
            # 휴장일: 전일 데이터 사용 (정상 처리)
            pass
        elif market_state == 'PRE':
            # 장 전: 프리마켓 데이터 (정상 처리)
            pass
        elif market_state == 'POST':
            # 장 후: 애프터마켓 데이터 (정상 처리)
            pass
        elif market_state == 'REGULAR':
            # 정규 장중: 실시간 데이터 (정상 처리)
            pass
        else:
            # 알 수 없는 상태: 로깅 후 계속 진행
            print(f"Warning: Unknown market state: {market_state}")
        
        # 거래량 기준 정렬
        quotes.sort(key=lambda x: x.get('regularMarketVolume', 0), reverse=True)
        
        top_stock = quotes[0]
        
        return {
            'symbol': top_stock.get('symbol'),
            'shortName': top_stock.get('shortName', ''),
            'regularMarketPrice': top_stock.get('regularMarketPrice', 0),
            'regularMarketChangePercent': top_stock.get('regularMarketChangePercent', 0),
            'regularMarketVolume': top_stock.get('regularMarketVolume', 0),
            'marketState': market_state
        }
    
    except Exception as e:
        print(f"Error: {e}")
        return None
```

### 5.3 재시도 로직

```python
import time
from functools import wraps

def retry_on_failure(max_retries=3, delay=1):
    """
    실패 시 재시도 데코레이터
    
    Args:
        max_retries: 최대 재시도 횟수
        delay: 재시도 간 대기 시간(초)
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    if attempt < max_retries - 1:
                        print(f"Attempt {attempt + 1} failed: {e}. Retrying in {delay} seconds...")
                        time.sleep(delay)
                    else:
                        print(f"All {max_retries} attempts failed.")
            
            raise last_exception
        
        return wrapper
    return decorator

@retry_on_failure(max_retries=3, delay=2)
def get_top_stock_with_retry():
    """재시도 로직이 포함된 TOP 종목 조회"""
    screener = Screener()
    data = screener.get_screeners('most_actives', count=10)
    
    if not data or 'most_actives' not in data:
        raise ValueError("No data available")
    
    quotes = data['most_actives']['quotes']
    if not quotes:
        raise ValueError("Empty quotes list")
    
    quotes.sort(key=lambda x: x.get('regularMarketVolume', 0), reverse=True)
    return quotes[0]
```

### 5.4 엣지 케이스 체크리스트

| 케이스 | 처리 방법 |
|--------|----------|
| **데이터 없음** | API 응답이 None이거나 빈 딕셔너리인 경우 → 에러 로깅 후 None 반환 |
| **빈 리스트** | quotes가 빈 리스트인 경우 → 에러 로깅 후 None 반환 |
| **중복 종목** | 심볼 기준으로 중복 제거 |
| **유효하지 않은 데이터** | volume ≤ 0 또는 price ≤ 0인 종목 필터링 |
| **심볼 누락** | symbol이 None이거나 빈 문자열인 경우 제외 |
| **시장 휴장** | CLOSED 상태일 때 전일 데이터 사용 (정상 처리) |
| **네트워크 오류** | 재시도 로직 적용 (최대 3회) |
| **API 변경** | KeyError 발생 시 에러 로깅 및 폴백 처리 |
| **점수 동점** | 거래량이 더 높은 종목 우선 선택 |

---

## 6. 최종 통합 함수

```python
def get_today_trending_stock():
    """
    최종 통합 함수: 모든 엣지 케이스를 고려한 안전한 구현
    
    Returns:
        dict: {
            'success': bool,
            'stock': {
                'symbol': str,
                'name': str,
                'price': float,
                'change_percent': float,
                'volume': int,
                'market_state': str
            } or None,
            'error': str or None,
            'timestamp': str
        }
    """
    from datetime import datetime
    
    result = {
        'success': False,
        'stock': None,
        'error': None,
        'timestamp': datetime.now().isoformat()
    }
    
    try:
        screener = Screener()
        
        # 거래량 상위 조회 (재시도 포함)
        for attempt in range(3):
            try:
                data = screener.get_screeners('most_actives', count=30)
                break
            except Exception as e:
                if attempt == 2:
                    result['error'] = f'Failed to fetch data after 3 attempts: {str(e)}'
                    return result
                time.sleep(2)
        
        # 데이터 검증
        if not data or 'most_actives' not in data:
            result['error'] = 'Invalid API response structure'
            return result
        
        quotes = data['most_actives'].get('quotes', [])
        if not quotes:
            result['error'] = 'No quotes in response'
            return result
        
        # 유효한 종목 필터링 및 중복 제거
        seen_symbols = set()
        valid_stocks = []
        
        for quote in quotes:
            symbol = quote.get('symbol', '').strip()
            volume = quote.get('regularMarketVolume', 0)
            price = quote.get('regularMarketPrice', 0)
            
            # 유효성 검사
            if not symbol or symbol in seen_symbols:
                continue
            
            if volume <= 0 or price <= 0:
                continue
            
            seen_symbols.add(symbol)
            valid_stocks.append(quote)
        
        if not valid_stocks:
            result['error'] = 'No valid stocks after filtering'
            return result
        
        # 거래량 기준 정렬
        valid_stocks.sort(key=lambda x: x.get('regularMarketVolume', 0), reverse=True)
        top_stock = valid_stocks[0]
        
        # 최종 결과 구성
        result['success'] = True
        result['stock'] = {
            'symbol': top_stock.get('symbol'),
            'name': top_stock.get('shortName', 'Unknown'),
            'price': float(top_stock.get('regularMarketPrice', 0)),
            'change': float(top_stock.get('regularMarketChange', 0)),
            'change_percent': float(top_stock.get('regularMarketChangePercent', 0)),
            'volume': int(top_stock.get('regularMarketVolume', 0)),
            'market_state': top_stock.get('marketState', 'UNKNOWN')
        }
        
        return result
    
    except Exception as e:
        result['error'] = f'Unexpected error: {str(e)}'
        return result
```

---

## 7. 사용 예시

```python
# 기본 사용
if __name__ == "__main__":
    # 방법 1: 간단한 조회
    top_stock = select_top_trending_stock()
    if top_stock:
        print(f"오늘의 화제 종목: {top_stock['symbol']} - {top_stock['shortName']}")
        print(f"거래량: {top_stock['regularMarketVolume']:,}")
        print(f"변동률: {top_stock['regularMarketChangePercent']:.2f}%")
    
    # 방법 2: 안전한 조회 (에러 처리 포함)
    result = get_today_trending_stock()
    if result['success']:
        stock = result['stock']
        print(f"선정 성공: {stock['symbol']} ({stock['name']})")
        print(f"가격: ${stock['price']:.2f}")
        print(f"변동률: {stock['change_percent']:.2f}%")
        print(f"거래량: {stock['volume']:,}")
    else:
        print(f"선정 실패: {result['error']}")
```

---

**작성일**: 2024년 12월  
**버전**: 1.0

