# 화제 종목 수집 방법 설계서 (코드 + 설명)

## 1) 목표
매 거래일 기준으로 **“오늘 화제 종목 TOP N”**을 산출한다.

### 정의(예시)
화제 종목 = “평소 대비 거래량이 급증하거나 변동성이 커서 시장 참여자가 집중한 종목”

## 2) 입력 데이터(원천)
실서비스 기준(예시)
- 시세: 현재가/전일종가/고가/저가/시가
- 거래량: 당일 거래량, 과거 평균 거래량(예: 20일)
- 변동성: 일중 변동폭, ATR 등(선택)
- 뉴스/이슈(선택): 기사 수, 키워드 트렌드, 공시 이벤트

현재 프로젝트는 **목업 데이터 기반 UI**이므로, 아래 설계는 “어떤 데이터를 모으면 좋고, 점수로 어떻게 선정할지”에 대한 설계 문서입니다.

## 3) 점수화(Scoring) 설계
### 3-1. 구성 요소
- 거래량 점수 \(S_v\)
  - 예: volumeRatio = todayVolume / avg20dVolume
  - \(S_v = \min(100, 50 \cdot \log_2(1 + volumeRatio))\)
- 변동성 점수 \(S_p\)
  - 예: absReturn = |(close - prevClose)/prevClose|
  - \(S_p = \min(100, 200 \cdot absReturn)\)
- 이슈 점수 \(S_n\) (선택)
  - 예: 뉴스 개수, 소셜 언급량 등
  - \(S_n = \min(100, 10 \cdot newsCount)\)

### 3-2. 최종 점수
\[
S = w_v S_v + w_p S_p + w_n S_n
\]
- 기본 가중치 예시: \(w_v=0.5, w_p=0.4, w_n=0.1\)

## 4) 필터링/정규화 정책
### 4-1. 거래대금/유동성 필터(선택)
- 극단적으로 작은 거래량 종목 제외(스팸/저유동성)

### 4-2. 섹터/테마 편향 완화(선택)
- TOP N이 한 섹터에 과도하게 몰리면 섹터별 cap 적용

### 4-3. 장 상태 고려
- 프리/정규/애프터 구분하여 계산하거나, “정규장 기준”으로 통일

## 5) 결과 산출 및 저장
- 매일 특정 시각(예: 장 종료+30분)에 배치 잡 실행
- TOP N 결과를 DB에 저장
  - `date`, `rank`, `symbol`, `score`, `volume`, `changePercent`, `reason` 등

## 6) 구현 예시 코드(의사코드)

> 아래 코드는 “설계 이해를 돕는 예시”입니다. 실제 API/DB 연동 시 코드 구조를 그대로 가져가되, 데이터 소스/타입만 교체하면 됩니다.

```ts
type MarketRow = {
  symbol: string;
  close: number;
  prevClose: number;
  volume: number;
  avg20dVolume: number;
  newsCount?: number;
};

function clamp(x: number, min: number, max: number) {
  return Math.max(min, Math.min(max, x));
}

function scoreRow(row: MarketRow) {
  const volumeRatio = row.avg20dVolume > 0 ? row.volume / row.avg20dVolume : 0;
  const absReturn = row.prevClose > 0 ? Math.abs((row.close - row.prevClose) / row.prevClose) : 0;
  const newsCount = row.newsCount ?? 0;

  const Sv = clamp(50 * Math.log2(1 + volumeRatio), 0, 100);
  const Sp = clamp(200 * absReturn, 0, 100);
  const Sn = clamp(10 * newsCount, 0, 100);

  const wv = 0.5, wp = 0.4, wn = 0.1;
  const score = wv * Sv + wp * Sp + wn * Sn;

  return {
    symbol: row.symbol,
    score,
    metrics: { volumeRatio, absReturn, newsCount, Sv, Sp, Sn },
  };
}

export function pickTopStocks(rows: MarketRow[], topN: number) {
  // 1) 필터링(예: avg20dVolume 너무 낮은 종목 제외)
  const filtered = rows.filter(r => r.avg20dVolume >= 100_000);

  // 2) 점수 계산
  const scored = filtered.map(scoreRow);

  // 3) 정렬 후 TOP N
  const top = scored.sort((a, b) => b.score - a.score).slice(0, topN);

  // 4) reason 생성(설명 가능한 선정 사유)
  return top.map((t, idx) => ({
    rank: idx + 1,
    symbol: t.symbol,
    score: Number(t.score.toFixed(2)),
    reason:
      t.metrics.volumeRatio >= 2
        ? '거래량 급증'
        : t.metrics.absReturn >= 0.03
          ? '변동성 확대'
          : '종합 점수 상위',
  }));
}
```

## 7) UI/목업과의 연결(현재 프로젝트)
- 현재 UI는 `lib/mockData.ts`의 `mockTop3Stocks`로 TOP3를 표시합니다.
- 실데이터 연동 시에는 “TOP3 API 응답 → 컴포넌트 props”로 교체하면 됩니다.


